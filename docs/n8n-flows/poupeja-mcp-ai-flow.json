{
  "name": "PoupeJ√° MCP + OpenAI + Supabase Flow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "poupeja-mcp-webhook",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "üéØ Webhook PoupeJ√° MCP",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "poupeja-mcp-webhook"
    },
    {
      "parameters": {
        "jsCode": "// üì• PROCESSAMENTO INICIAL DOS DADOS\nconst payload = $json;\nconsole.log('üì• Payload recebido:', JSON.stringify(payload, null, 2));\n\n// Valida√ß√£o b√°sica do payload\nif (!payload || !payload.user) {\n  throw new Error('‚ùå Payload inv√°lido: dados do usu√°rio ausentes');\n}\n\nconst userData = payload.user;\nconst eventData = payload.data || {};\nconst eventType = payload.type || 'custom';\n\nconsole.log('üë§ Dados do usu√°rio:', userData);\nconsole.log('üìä Tipo de evento:', eventType);\nconsole.log('üìã Dados do evento:', eventData);\n\n// Normalizar telefone brasileiro\nfunction normalizeBrazilianPhone(phone) {\n  if (!phone) return null;\n  \n  // Remove todos os caracteres n√£o num√©ricos\n  let cleanPhone = phone.replace(/\\D/g, '');\n  console.log('üì± Telefone limpo:', cleanPhone);\n  \n  // Remove c√≥digo do pa√≠s 55 se presente\n  if (cleanPhone.startsWith('55')) {\n    cleanPhone = cleanPhone.substring(2);\n    console.log('üì± Ap√≥s remover 55:', cleanPhone);\n  }\n  \n  // Adiciona 9¬∫ d√≠gito se necess√°rio (DDD + 8 d√≠gitos = celular)\n  if (cleanPhone.length === 10 && ['6', '7', '8', '9'].includes(cleanPhone.charAt(2))) {\n    cleanPhone = cleanPhone.substring(0, 2) + '9' + cleanPhone.substring(2);\n    console.log('üì± Ap√≥s adicionar 9¬∫ d√≠gito:', cleanPhone);\n  }\n  \n  // Adiciona c√≥digo do pa√≠s\n  if (cleanPhone.length === 11) {\n    cleanPhone = '55' + cleanPhone;\n    console.log('üì± Telefone final:', cleanPhone);\n  }\n  \n  // Valida√ß√£o final\n  if (cleanPhone.length !== 13) {\n    console.warn('‚ö†Ô∏è Telefone com formato inv√°lido:', cleanPhone);\n    return null;\n  }\n  \n  return cleanPhone;\n}\n\nconst normalizedPhone = normalizeBrazilianPhone(userData.phone);\nif (!normalizedPhone) {\n  throw new Error('‚ùå Telefone inv√°lido ou ausente');\n}\n\n// Configura√ß√£o da Evolution API do payload\nconst evolutionConfig = payload.metadata?.evolutionApi || {};\n\n// Preparar dados para pr√≥ximo node\nconst processedData = {\n  user: {\n    id: userData.id,\n    name: userData.name,\n    email: userData.email,\n    phone: normalizedPhone\n  },\n  event: {\n    type: eventType,\n    data: eventData,\n    timestamp: new Date().toISOString()\n  },\n  evolution: {\n    apiUrl: evolutionConfig.apiUrl || 'https://evolution-api.example.com',\n    apiKey: evolutionConfig.apiKey || '',\n    instance: evolutionConfig.instance || 'default'\n  },\n  originalPayload: payload\n};\n\nconsole.log('‚úÖ Dados processados com sucesso:', JSON.stringify(processedData, null, 2));\n\nreturn processedData;"
      },
      "id": "data_processor",
      "name": "‚öôÔ∏è Processador de Dados",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// üîç BUSCAR DADOS CONTEXTUAIS NO SUPABASE\nconst data = $json;\nconst userId = data.user.id;\n\nconsole.log('üîç Buscando dados contextuais para usu√°rio:', userId);\n\n// Preparar queries para buscar dados do usu√°rio\nconst supabaseQueries = {\n  // Dados do perfil do usu√°rio\n  userProfile: {\n    table: 'poupeja_users',\n    select: 'name, email, phone, profile_image',\n    filter: `id=eq.${userId}`\n  },\n  \n  // √öltimas transa√ß√µes (√∫ltimos 30 dias)\n  recentTransactions: {\n    table: 'poupeja_transactions',\n    select: 'id, type, amount, description, date, created_at',\n    filter: `user_id=eq.${userId}&date=gte.${new Date(Date.now() - 30*24*60*60*1000).toISOString().split('T')[0]}`,\n    order: 'date.desc',\n    limit: 10\n  },\n  \n  // Metas ativas\n  activeGoals: {\n    table: 'poupeja_goals',\n    select: 'id, name, target_amount, current_amount, deadline',\n    filter: `user_id=eq.${userId}&deadline=gte.${new Date().toISOString().split('T')[0]}`,\n    order: 'deadline.asc'\n  },\n  \n  // Or√ßamentos ativos\n  activeBudgets: {\n    table: 'poupeja_budgets',\n    select: 'id, amount, period, start_date, end_date',\n    filter: `user_id=eq.${userId}&end_date=gte.${new Date().toISOString().split('T')[0]}`\n  },\n  \n  // Categorias do usu√°rio\n  userCategories: {\n    table: 'poupeja_categories',\n    select: 'id, name, type, color, icon',\n    filter: `user_id=eq.${userId}`\n  }\n};\n\n// Preparar dados para o pr√≥ximo node (Supabase Fetcher)\nconst contextData = {\n  ...data,\n  supabaseQueries,\n  contextNeeded: true\n};\n\nconsole.log('üìä Queries preparadas:', Object.keys(supabaseQueries));\n\nreturn contextData;"
      },
      "id": "context_builder",
      "name": "üß† Construtor de Contexto",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// üìö SIMULA√á√ÉO DE DADOS DO SUPABASE (MOCK)\n// Em um cen√°rio real, aqui voc√™ faria as queries reais no Supabase\nconst data = $json;\nconst userId = data.user.id;\n\nconsole.log('üìö Simulando busca de dados contextuais para usu√°rio:', userId);\n\n// Mock de dados realistas baseados no esquema do Supabase\nconst mockContextData = {\n  userProfile: {\n    name: data.user.name,\n    email: data.user.email,\n    phone: data.user.phone,\n    profile_image: null\n  },\n  \n  recentTransactions: [\n    {\n      id: 'trans_001',\n      type: 'expense',\n      amount: -150.50,\n      description: 'Supermercado',\n      date: new Date(Date.now() - 2*24*60*60*1000).toISOString().split('T')[0]\n    },\n    {\n      id: 'trans_002', \n      type: 'income',\n      amount: 3500.00,\n      description: 'Sal√°rio',\n      date: new Date(Date.now() - 5*24*60*60*1000).toISOString().split('T')[0]\n    },\n    {\n      id: 'trans_003',\n      type: 'expense', \n      amount: -85.30,\n      description: 'Combust√≠vel',\n      date: new Date(Date.now() - 7*24*60*60*1000).toISOString().split('T')[0]\n    }\n  ],\n  \n  activeGoals: [\n    {\n      id: 'goal_001',\n      name: 'Viagem para Europa',\n      target_amount: 8000.00,\n      current_amount: 2350.00,\n      deadline: new Date(Date.now() + 180*24*60*60*1000).toISOString().split('T')[0]\n    },\n    {\n      id: 'goal_002',\n      name: 'Reserva de Emerg√™ncia',\n      target_amount: 10000.00,\n      current_amount: 4200.00,\n      deadline: new Date(Date.now() + 365*24*60*60*1000).toISOString().split('T')[0]\n    }\n  ],\n  \n  activeBudgets: [\n    {\n      id: 'budget_001',\n      amount: 1500.00,\n      period: 'monthly',\n      start_date: new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0],\n      end_date: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0).toISOString().split('T')[0]\n    }\n  ],\n  \n  userCategories: [\n    { id: 'cat_001', name: 'Alimenta√ß√£o', type: 'expense', color: '#EF4444', icon: 'utensils' },\n    { id: 'cat_002', name: 'Transporte', type: 'expense', color: '#3B82F6', icon: 'car' },\n    { id: 'cat_003', name: 'Sal√°rio', type: 'income', color: '#10B981', icon: 'briefcase' }\n  ]\n};\n\n// Combinar dados originais com contexto\nconst enrichedData = {\n  ...data,\n  context: mockContextData,\n  contextFetched: true\n};\n\nconsole.log('‚úÖ Contexto simulado criado com sucesso');\nconsole.log('üìä Transa√ß√µes recentes:', mockContextData.recentTransactions.length);\nconsole.log('üéØ Metas ativas:', mockContextData.activeGoals.length);\nconsole.log('üí∞ Or√ßamentos ativos:', mockContextData.activeBudgets.length);\n\nreturn enrichedData;"
      },
      "id": "supabase_fetcher",
      "name": "üóÑÔ∏è Buscar Dados Supabase",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "jsCode": "// ü§ñ PREPARAR PROMPT PARA OPENAI COM CONTEXTO MCP\nconst data = $json;\nconst user = data.user;\nconst event = data.event;\nconst context = data.context;\n\nconsole.log('ü§ñ Preparando prompt para OpenAI...');\n\n// Construir contexto rico para o AI\nconst userContext = `\n**PERFIL DO USU√ÅRIO:**\n- Nome: ${user.name}\n- Email: ${user.email}\n- ID: ${user.id}\n\n**SITUA√á√ÉO FINANCEIRA ATUAL:**\n- Transa√ß√µes recentes (${context.recentTransactions.length} transa√ß√µes):\n${context.recentTransactions.map(t => \n  `  ‚Ä¢ ${t.date}: ${t.type === 'income' ? '+' : ''}R$ ${t.amount.toFixed(2)} - ${t.description}`\n).join('\\n')}\n\n**METAS FINANCEIRAS:**\n${context.activeGoals.map(g => \n  `  ‚Ä¢ ${g.name}: R$ ${g.current_amount.toFixed(2)} / R$ ${g.target_amount.toFixed(2)} (${((g.current_amount/g.target_amount)*100).toFixed(1)}%) - Prazo: ${g.deadline}`\n).join('\\n')}\n\n**OR√áAMENTOS ATIVOS:**\n${context.activeBudgets.map(b => \n  `  ‚Ä¢ ${b.period}: R$ ${b.amount.toFixed(2)} (${b.start_date} at√© ${b.end_date})`\n).join('\\n')}\n`;\n\n// Determinar o tipo de mensagem baseado no evento\nlet eventDescription = '';\nlet messagePurpose = '';\n\nswitch(event.type) {\n  case 'appointment_created':\n  case 'appointment_reminder':\n    eventDescription = `Compromisso: ${event.data.title} em ${event.data.date}`;\n    messagePurpose = 'lembrete de compromisso';\n    break;\n    \n  case 'transaction_due':\n  case 'transaction_reminder':\n    eventDescription = `Transa√ß√£o pendente: ${event.data.description} - R$ ${event.data.amount}`;\n    messagePurpose = 'lembrete de pagamento';\n    break;\n    \n  case 'goal_progress':\n    eventDescription = `Progresso na meta: ${event.data.title}`;\n    messagePurpose = 'atualiza√ß√£o de progresso de meta';\n    break;\n    \n  case 'goal_achieved':\n    eventDescription = `Meta alcan√ßada: ${event.data.title}`;\n    messagePurpose = 'parabeniza√ß√£o por meta alcan√ßada';\n    break;\n    \n  case 'budget_exceeded':\n    eventDescription = `Or√ßamento excedido em: ${event.data.category}`;\n    messagePurpose = 'alerta de or√ßamento';\n    break;\n    \n  default:\n    eventDescription = event.data.description || 'Evento personalizado';\n    messagePurpose = 'mensagem personalizada';\n}\n\n// Prompt principal para o OpenAI\nconst systemPrompt = `Voc√™ √© o PoupeJ√° AI, um assistente financeiro inteligente e amig√°vel do aplicativo PoupeJ√°.\n\nSua fun√ß√£o √© criar mensagens personalizadas via WhatsApp para os usu√°rios com base em seus dados financeiros e contexto pessoal.\n\n**DIRETRIZES:**\n1. Seja amig√°vel, motivador e √∫til\n2. Use linguagem informal e brasileira\n3. Personalize a mensagem usando o contexto do usu√°rio\n4. Mantenha a mensagem concisa (m√°ximo 200 caracteres)\n5. Use emojis apropriados mas sem exagerar\n6. Inclua insights √∫teis baseados nos dados do usu√°rio\n7. Seja espec√≠fico sobre valores e datas quando relevante\n8. Motive o usu√°rio a continuar usando o PoupeJ√°\n\n**CONTEXTO DO USU√ÅRIO:**\n${userContext}\n\n**EVENTO ATUAL:**\n${eventDescription}\n\n**OBJETIVO DA MENSAGEM:**\nCriar um ${messagePurpose} personalizado e motivador.`;\n\nconst userPrompt = `Com base no contexto fornecido, crie uma mensagem personalizada para ${user.name} sobre: ${eventDescription}\n\nA mensagem deve ser:\n- Personalizada com base nos dados financeiros do usu√°rio\n- Motivadora e √∫til\n- Concisa (m√°ximo 200 caracteres)\n- Em portugu√™s brasileiro informal\n- Com emojis apropriados\n\nRetorne APENAS a mensagem, sem aspas ou formata√ß√£o adicional.`;\n\n// Preparar dados para OpenAI\nconst openaiData = {\n  ...data,\n  openai: {\n    systemPrompt,\n    userPrompt,\n    model: 'gpt-4o-mini',\n    maxTokens: 150,\n    temperature: 0.7\n  }\n};\n\nconsole.log('‚úÖ Prompt preparado para OpenAI');\nconsole.log('üìù Tamanho do contexto:', userContext.length, 'caracteres');\nconsole.log('üéØ Objetivo:', messagePurpose);\n\nreturn openaiData;"
      },
      "id": "ai_prompt_builder",
      "name": "üìù Construtor de Prompt IA",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "jsCode": "// ü§ñ SIMULAR RESPOSTA DO OPENAI\n// Em um cen√°rio real, aqui voc√™ faria a chamada para a API do OpenAI\nconst data = $json;\nconst openaiConfig = data.openai;\nconst user = data.user;\nconst event = data.event;\n\nconsole.log('ü§ñ Simulando chamada para OpenAI...');\nconsole.log('üìã Modelo:', openaiConfig.model);\nconsole.log('üå°Ô∏è Temperature:', openaiConfig.temperature);\n\n// Simular diferentes tipos de mensagens baseadas no evento\nlet aiGeneratedMessage = '';\n\nswitch(event.type) {\n  case 'appointment_created':\n  case 'appointment_reminder':\n    aiGeneratedMessage = `Oi ${user.name.split(' ')[0]}! üìÖ Lembrete: voc√™ tem \"${event.data.title}\" hoje. N√£o esque√ßa de registrar os gastos no PoupeJ√° depois! üíô`;\n    break;\n    \n  case 'transaction_due':\n  case 'transaction_reminder':\n    aiGeneratedMessage = `${user.name.split(' ')[0]}, est√° na hora! üí≥ ${event.data.description || 'Pagamento'} de R$ ${event.data.amount || '0,00'} vence hoje. J√° est√° no seu or√ßamento? üìä`;\n    break;\n    \n  case 'goal_progress':\n    const progress = event.data.progress || 0;\n    aiGeneratedMessage = `üéâ Parab√©ns ${user.name.split(' ')[0]}! Voc√™ est√° ${progress}% mais perto da sua meta \"${event.data.title}\". Continue assim! üí™`;\n    break;\n    \n  case 'goal_achieved':\n    aiGeneratedMessage = `üèÜ INCR√çVEL! ${user.name.split(' ')[0]}, voc√™ conquistou sua meta \"${event.data.title}\"! Que tal criar uma nova meta no PoupeJ√°? üöÄ`;\n    break;\n    \n  case 'budget_exceeded':\n    aiGeneratedMessage = `‚ö†Ô∏è Opa ${user.name.split(' ')[0]}! Seu or√ßamento de ${event.data.category || 'categoria'} passou do limite. Que tal revisar os gastos no PoupeJ√°? üì±`;\n    break;\n    \n  default:\n    aiGeneratedMessage = `Oi ${user.name.split(' ')[0]}! üëã ${event.data.description || 'Temos uma atualiza√ß√£o para voc√™ no PoupeJ√°!'} Confira o app! üì±üíô`;\n}\n\n// Simular delay da API (500ms)\nconst delay = 500;\nconsole.log(`‚è±Ô∏è Simulando delay de ${delay}ms...`);\n\n// Preparar resposta\nconst aiResponse = {\n  ...data,\n  aiMessage: aiGeneratedMessage,\n  aiProcessed: true,\n  processingTime: delay,\n  messageLength: aiGeneratedMessage.length\n};\n\nconsole.log('‚úÖ Mensagem IA gerada:', aiGeneratedMessage);\nconsole.log('üìè Tamanho da mensagem:', aiGeneratedMessage.length, 'caracteres');\n\nreturn aiResponse;"
      },
      "id": "openai_generator",
      "name": "ü§ñ Gerador OpenAI",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.aiProcessed}}",
              "value2": true
            }
          ]
        }
      },
      "id": "ai_validator",
      "name": "‚úÖ Validar IA",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "url": "={{$json.evolution.apiUrl}}/message/sendText/{{$json.evolution.instance}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "httpHeaderAuth": {
          "name": "apikey",
          "value": "={{$json.evolution.apiKey}}"
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{$json.user.phone}}"
            },
            {
              "name": "text",
              "value": "={{$json.aiMessage}}"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxTries": 3
          }
        }
      },
      "id": "whatsapp_sender",
      "name": "üì≤ Enviar WhatsApp",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1780, 240]
    },
    {
      "parameters": {
        "jsCode": "// üìä LOG DE SUCESSO COMPLETO\nconst data = $json;\nconst response = data;\n\nconst successLog = {\n  timestamp: new Date().toISOString(),\n  status: 'success',\n  user: {\n    id: data.user.id,\n    name: data.user.name,\n    phone: data.user.phone\n  },\n  event: {\n    type: data.event.type,\n    data: data.event.data\n  },\n  message: {\n    content: data.aiMessage,\n    length: data.aiMessage.length,\n    generated_by: 'openai',\n    model: data.openai?.model || 'simulated'\n  },\n  whatsapp: {\n    status: response.status || 200,\n    instance: data.evolution.instance,\n    api_url: data.evolution.apiUrl\n  },\n  processing: {\n    total_time_ms: Date.now() - new Date(data.event.timestamp).getTime(),\n    ai_processing_time_ms: data.processingTime || 0\n  }\n};\n\nconsole.log('‚úÖ SUCESSO - Mensagem enviada com sucesso!');\nconsole.log('üìä Log completo:', JSON.stringify(successLog, null, 2));\nconsole.log('üë§ Usu√°rio:', data.user.name);\nconsole.log('üì± Telefone:', data.user.phone);\nconsole.log('üí¨ Mensagem:', data.aiMessage);\nconsole.log('üïê Tempo total:', successLog.processing.total_time_ms, 'ms');\n\nreturn {\n  success: true,\n  log: successLog,\n  response: 'Mensagem enviada com sucesso via WhatsApp'\n};"
      },
      "id": "success_logger",
      "name": "üìä Log Sucesso",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 240]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ \n  {\n    \"success\": true,\n    \"message\": \"Mensagem AI personalizada enviada com sucesso\",\n    \"data\": {\n      \"user_id\": $json.user.id,\n      \"phone\": $json.user.phone,\n      \"message_sent\": $json.aiMessage,\n      \"event_type\": $json.event.type,\n      \"timestamp\": $json.log.timestamp,\n      \"processing_time_ms\": $json.log.processing.total_time_ms\n    }\n  }\n}}",
        "options": {}
      },
      "id": "success_response",
      "name": "‚úÖ Resposta Sucesso",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2220, 240]
    },
    {
      "parameters": {
        "jsCode": "// ‚ùå LOG DE ERRO COMPLETO\nconst error = $json.error || 'Erro desconhecido';\nconst data = $input.all()[0]?.json || {};\n\nconst errorLog = {\n  timestamp: new Date().toISOString(),\n  status: 'error',\n  error: {\n    message: error.message || error,\n    type: error.name || 'Unknown Error',\n    stack: error.stack || null\n  },\n  user: {\n    id: data.user?.id || 'unknown',\n    name: data.user?.name || 'unknown',\n    phone: data.user?.phone || 'unknown'\n  },\n  event: {\n    type: data.event?.type || 'unknown',\n    data: data.event?.data || {}\n  },\n  context: {\n    step_failed: 'ai_validation_or_whatsapp_sending',\n    ai_processed: data.aiProcessed || false,\n    message_generated: !!data.aiMessage\n  }\n};\n\nconsole.error('‚ùå ERRO - Falha no processamento!');\nconsole.error('üö® Detalhes do erro:', JSON.stringify(errorLog, null, 2));\nconsole.error('üë§ Usu√°rio afetado:', data.user?.name || 'Desconhecido');\nconsole.error('üì± Telefone:', data.user?.phone || 'Desconhecido');\nconsole.error('üîç Etapa que falhou:', errorLog.context.step_failed);\n\nreturn {\n  success: false,\n  error: errorLog,\n  response: 'Falha no processamento da mensagem IA'\n};"
      },
      "id": "error_logger",
      "name": "‚ùå Log Erro",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 380]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ \n  {\n    \"success\": false,\n    \"message\": \"Erro no processamento da mensagem IA\",\n    \"error\": {\n      \"type\": $json.error.error.type,\n      \"message\": $json.error.error.message,\n      \"timestamp\": $json.error.timestamp,\n      \"user_id\": $json.error.user.id,\n      \"step_failed\": $json.error.context.step_failed\n    }\n  }\n}}",
        "options": {}
      },
      "id": "error_response", 
      "name": "‚ùå Resposta Erro",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2000, 380]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [
        [
          {
            "node": "data_processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "data_processor": {
      "main": [
        [
          {
            "node": "context_builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "context_builder": {
      "main": [
        [
          {
            "node": "supabase_fetcher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "supabase_fetcher": {
      "main": [
        [
          {
            "node": "ai_prompt_builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ai_prompt_builder": {
      "main": [
        [
          {
            "node": "openai_generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "openai_generator": {
      "main": [
        [
          {
            "node": "ai_validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ai_validator": {
      "main": [
        [
          {
            "node": "whatsapp_sender",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "error_logger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "whatsapp_sender": {
      "main": [
        [
          {
            "node": "success_logger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "success_logger": {
      "main": [
        [
          {
            "node": "success_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "error_logger": {
      "main": [
        [
          {
            "node": "error_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-27T00:00:00.000Z",
  "versionId": "1"
}